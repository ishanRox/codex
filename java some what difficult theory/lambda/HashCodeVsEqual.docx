HashCode Vs Equals Methods


== operator and equals()  (OBJECT Context)

1.if r1==r2 is true then always r1.equals(r2) is always true.
 

2.if r1==r2 is false then we cant conclude about r1.equals(r2) may or may not be  is  true.

3.r1.equals(r2) TRUE then we cant conclude anything about == operator it may return true or false(Because equal check inside property of object it may be overriden).

3.r1.equals(r2) False(Both reference  are not pointing to same object exactly) then  == operator always false.


Difference Between == and .equals()

String  s1= new String(“ishan”);

String  s2= new String(“ishan”);

StringBuffer  sb1= new StringBuffer(“ishan”);

StringBuffer  sb2= new StringBuffer(“ishan”);


sout(s1=s2);false
sout(s1.equals(s2));true


sout(sb1=sb2);false
sout(sb1.equals(sb2));false
(not overriden to compare values like String)


sout(s1=sb1);compile error
 (incomparable types java.lang.String and java .lang )
sout(s1.equals(sb1));
equals method dont give errors so but return false with different objects



             
== operator
 

For content comparition
Method only for objects
Can override
Different types provide false
      





 equals() method

For reference comparition
Operator can apply for object and primitives
Cannot override
Different types give compile error



When both gives same results

object == null
object.equals(null)

both gives false








Contract Between equals() and HashCode()
Method 



But this is not simpel as this a detailed explanation is needed !

Java equals() and hashCode() Contract 
  

The Java super class java.lang.Object defines two important methods:

public boolean equals(Object obj)
public int hashCode()
In this post, I will first show an example of a common mistake, and then explain how the equals() and hashCode() contract works. 
1. A common mistake 

import java.util.HashMap;
 
public class Apple {
        private String color;
 
        public Apple(String color) {
                this.color = color;
        }
 
        public boolean equals(Object obj) {
                if(obj==null) return false;
                if (!(obj instanceof Apple))
                        return false;   
                if (obj == this)
                        return true;
                return this.color.equals(((Apple) obj).color);
        }
 
        public static void main(String[] args) {
                Apple a1 = new Apple("green");
                Apple a2 = new Apple("red");
 
                //hashMap stores apple type and its quantity
                HashMap<Apple, Integer> m = new HashMap<Apple, Integer>();
                m.put(a1, 10);
                m.put(a2, 20);
                System.out.println(m.get(new Apple("green")));
        }
}


The common mistake is shown in the example below.
import java.util.HashMap;
 
public class Apple {
        private String color;
 
        public Apple(String color) {
                this.color = color;
        }
 
        public boolean equals(Object obj) {
                if(obj==null) return false;
                if (!(obj instanceof Apple))
                        return false;   
                if (obj == this)
                        return true;
                return this.color.equals(((Apple) obj).color);
        }
 
        public static void main(String[] args) {
                Apple a1 = new Apple("green");
                Apple a2 = new Apple("red");
 
                //hashMap stores apple type and its quantity
                HashMap<Apple, Integer> m = new HashMap<Apple, Integer>();
                m.put(a1, 10);
                m.put(a2, 20);
                System.out.println(m.get(new Apple("green")));
        }
}

In the main method, two apples ("green" and "red") are created and put to a HashMap. However, when the map is asked to provide the green apple, the green apple is not found. The program above prints null. We are sure that the green apple is stored in the hashMap when inspecting the HashMap in the debugger. 

What causes the issue?

2. Problem caused by hashCode()

The problem is caused by the un-overridden method "hashCode()". The contract between equals() and hashCode() is:

1) If two objects are equal, then they must have the same hash code.

2) If two objects have the same hash code, they may or may not be equal. 


Ara krishan ayiya kiwwa hash walath same enna possibility thiyena seen eka 
StackoverFlow answer eka
If two objects have the same hashcode then they are NOT necessarily equal. Otherwise you will have discovered the perfect hash function. 
But the opposite is true: if the objects are equal, then they must have the same hashcode.


The idea behind a Map is to be able to find an object faster than a linear search. Using hashed keys to locate objects is a two-step process. Internally, the HashMap is implemented as an array of Entry objects. Each Entry has a 
The default implementation of hashCode() in Object class returns distinct integers for different objects. Therefore, the second apple has a different hash code. 
The HashMap is organized like a sequence of buckets. The key objects are put into different buckets. It takes time of O(1) to get to the right bucket because it is an array access with the index. Therefore, it's a good practice to evenly distribute the objects into those buckets, i.e., having a hashCode() method that produces evenly distributed hash code. (Not the main point here though)
The solution is to add the hashCode method to the Apple class. Here I just use the color string's length for demonstration.

public int hashCode(){
        return this.color.hashCode();   
}








